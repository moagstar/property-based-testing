Let's say for example that we need a run length encoding function, where repeated consecutive data points are replaced with a single instance and the number of occurences. Of course we do what any good programmer would do and use stack overflow or rosetta code to find an implemenation that suits our needs. This implementation is taken from rosetta code, with one amendment to turn the output into a string.

However there are two problems with these tests, firstly I only tested one input. It is not possible to catch all the edge cases by just testing one input, so a better way is to parameterize the test so that we can supply multiple inputs. Another problem is that there are two tests, however we repeated the text and expected in both tests, if we are parameterizing then we can make the test more general by using the output encode as the input to decode

What about performing the same operation 2 or 3 times in a row? Or passing different values to the various arguments these operations take? As we can see, in even the simplest of systems the number of test cases for a brute force method is unmanageable. There must be a better way. Of course not all permutations are valid, for example we don't want a test case of the form put, get, new, size - it doesn't make sense to do perform any of the other operations on a queue until after it is created. What we need is a way to specify the valid operations for the system under test. In hypothesis we can derive a class from RuleBasedStateMachine where methods decorated with @rule are treated as states in the system. The @rule decorator is a bit like the @given decorator, defining the strategies to use for generating argument values. However @rule is only allowed in the context of a RuleBasedStateMachine. All transitions between states are assumed valid, but the @precondition decorator can be used on a method to indicate whether a transition to this state is valid or not. In this way we can build a specification for the system under test. Using the Queue example, this is how the specification would look. To create a new queue we have the precondition that the queue must not already be created. For all other operations we check the precondition that the queue must have been created. And to get an item from the queue, we want to check that the queue is not empty.

Besides specifying the various states and valid transitions, we want these methods to actually invoke the operation it represents on the system under test, but also we want to have a model which represents our system under test, and perform some similar operation on the model as well. We can then assert post conditions comparing the model and the system under test to determine if we got the expected behaviour or not. Of course you don't have to use a model, you can assert other properties about the system under test using this method. So in our queue example we can use a list as our model.

RuleBasedStateMachine exposes a TestCase class which can be used like the standard TestCase classes. Let's run some tests. As you can see we got some failures, let's have a look at the error, it appears we created a new queue of size 2, we put a 0 into it, then put a 1 into it, and the performed a get. If we look at the assertion failure, we see that by the get our system under test gave us a 0, while the model gave us a 1. Now this is a FIFO queue, which is the behaviour we see from the actual system under test. We have here a bug in our model, our model is insufficient to represent the system under test. Luckily we can fix that by changing the append to a prepend in the put state.

This time we encounter a different error. We create a new queue of size 1, we put a 0 into it, then put another 0 into it, and then ask for the size. Our actual system under test reports 0, while the model reports 2. Now the 0 is clearly wrong, but what is going on here? Well I create a queue of size 1 and then I put 2 items into it. It's debatable about what the system should actually do here, maybe raise an exception, but for the sake of the tests we generated an invalid test case here, so this is a bug in our specification. We can fix this by altering the pre condition to ensure we don't try and put items on the queue if it is already full.

Now we get yet another error, this time with create a new queue of size 1, we put an item into it and we ask the size. Our model gives the correct answer, 1, but our actual system under test gives a size of 0, that's clearly wrong, I think this is a bug in the actual implementation of the system under test. Let's take a look at what is going here.